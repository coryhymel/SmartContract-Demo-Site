//
// Below is a basic example of how to use a smart contract in conjunction
// with an HTML page. The smart contract is written in Solidity.
// In this example we are deploying the contract in a test environment
// using 'testrpc', which also gives us 10 test accounts.
//
// NOTES:
// If not working for some reason make sure you have 1_initial_migration.js updated
// Have ran truffle migrate --reset
//

// The web3.js library is a collection of modules which contain specific functionality for the ethereum ecosystem.
web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));



// This has to be updated each time we change the .sol code.
// Can obtain an updated version from: https://ethereum.github.io/browser-solidity/#optimize=false&version=soljson-v0.4.21+commit.dfe3193c.js
// Then -> "Details" button on the right
// When you pass into .contract() is the ABI of the smart contract.
//   ---- DOCS:-----
// When you create a new contract object you give it the json interface of the
// respective smart contract and web3 will auto convert all calls into low level ABI calls over RPC for you.
//   ---------------
var proofofexistence1Contract = web3.eth.contract([{"constant":true,"inputs":[{"name":"document","type":"string"}],"name":"testCheckDocument","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"document","type":"string"}],"name":"checkDocument","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"document","type":"string"}],"name":"notarize","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"proof","type":"bytes32"}],"name":"storeProof","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"proof","type":"bytes32"}],"name":"hasProof","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"document","type":"string"}],"name":"proofFor","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"}]);


// The .at() address has to be updated each time we use a different deployed contract
// This here basically is our instance of our contract
var notarizeInstance = proofofexistence1Contract.at('0xbbbe7ce00ec7782f4858584d5d935b349707571f');


//
// Function that grabs text from the input box and notarizes it with our smart contract
//
function notarizeString() {

  notarizeString = $("#stringToNotarize").val();

  // we pass in an account since this method is transactional thus causing
  // an update to the blockchain. We get this accounts[0], which was
  // generated by testrpc when we launched it.
  notarizeInstance.notarize(notarizeString, {from: web3.eth.accounts[0]}, function(err) {
    if (err) {
      return console.error(err);
    }

    console.log("string has been notarized");
  });
}


//
// Function to check if a string has been notarized before.
//
function checkNotarization() {

  stringToCheck = $("#checkNotarization").val();

  notarizeInstance.checkDocument(stringToCheck, function(err, retVal) {
      if (err) { return console.error(err); }

      if (retVal == true) {
        console.log("this string matches the original");
      } else {
        console.log("this does NOT match the original");
      }
  });\
}

$(document).ready(function() { });
